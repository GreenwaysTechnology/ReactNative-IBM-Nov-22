                                             React Native
..............................................................................................

What is React Native?

1.React Native is lib for building native mobile apps 
2.React Native combines the best parts of native development with React, a best-in-class  JavaScript library for building user interfaces.

Mobile App development:

 Mobile apps are built using mobile platforms and os.

Mobile platforms:
1.Android
2.Ios

Mobile devices are acting front end devices, user interfaces communicates back end services.

Dev:
 1.user interface developer/front end developer
 2.back end developer
 3.full stack developer.

Front end developer who dev apps for  front devices.

Devices:
 1.computers - desktop
 2.Hand held devices- Mobiles,Tabs..
 3.TV,Game consoles
 4.IOT devices- It could be any - watches,car,industrial apps,

Dev generally build apps for desktops:
  Standalone desktop apps
  Browser based apps- javascript,html,css - react,angular,vue.....

Mobile /Tab apps:
 Dev builds apps for android platform using java , kotlin pl.
 in iOS development, you use Swift or Objective-C.

Types of mobile Apps:
.....................

1.Native Mobile
2.Web apps
3.Hybrid apps

1.Native Mobile
   Mobiles built by using native platform languages- java / Swift.
2.Web apps
   Apps built for browsers -Mobile browsers
3.Hybrid  apps
   built apps using javascript but it wont run inside browser, runs inside mobile using   container(WebView).


Hybrid apps:

 Application built using javascript,css,html,looks like native apps.

Why Hybrid Apps?

-incase native apps, we need to maintain two code base for both platform.

Why not to build one single portable app for all platforms?

 That is birth of hybrid apps.

Hybrids apps can be built using existing web tech- js,css,html.
Js is simple dom language, how to acess platform services such as contacts,networks,storage..
- a lib was created -cordova , based on cordova adobe started building a framework on top of the cordova , called phoneGap.

...........................................................................................

How to build mobile native apps in portable way using same javascript technology without html and css?

		That is birth of React Native.

/////////////////////////////////////////////////////////////////////////////////////

React Native Application Architecture :
...........................

React native applications are written using react(js) core principles
 -Components
 -Props
 -State
 -Event Handling
 -JSX

           "Every react native apps are simple javascript code"

 "In React Native, there is no webview concept. React native never run inside browser."
...............................................................................
			How react native works?


if you want to understand react native, we need to understand the source code react native.

we write code in react using jsx language.
jsx language mixes of html code + javascript 

1.UI MARK UP Code
   -  incase of react , html is mark up

UI Mark Up code for React native:

React native does not use html language to build ui elements.
React Native provides a high level ui components already written, so we can use those
components only.Why?
 We are building portable application either for android or ios.
So we need generic concept for both  platforms. 
For that React native provides a generic components for both platforms.

.....................................................................................
	   		 JSX Compilation Model
			     (browser)

                   layout.js / layout.jsx  -source code
		       |
		    compiler - babel.js 
			|
		    plain js code
			|-----------------------Dev cycle
	----------------------------------------- -- Excution cycles Starts
  Runtime : React Engine  compiled code feed into react engine
			|
		  Excute compiled js code : function calls
			|
	     create virtual Object tree (in browser V-dom)
		        |
		    Render Engine ; will convert react object tree into js dom object tree
			|
		   Flush the tree into target
			|
	--------------------------------------------
        |
       v8
     Browser			

React Native Compilation:

What is it? What is happening during compilation?

Source code is converted into another source code - Compilation.
Another code is platform specific code. android code or ios code.
if i  write ui components, ui components will be converted to platform spefic components.
javascript code will be emitted as it is-app code.



2.Application logic code
   - js code - apis,state,props......


1.Source Code
    written in react - UI Code and app logic

2.Compiled code
    code converted into platform specific code.

			React Native Source Code
			  (fileName.js or jsx)
				|
			     compiler
				|
		---------------------------------------------
		|                                           |
	  ui mark up                                  javascript code
		|
  compiled as platform specific code			   |
		|                                      Not Compiled
	-------------					   |
	|           |                                    
  Andorid          ios

-------------------------------------------------------------------------------------

Runtime Components:

1.All Views(User interface) elements are executed by "Platform runtimes"
2.All javascript code is exectued by javascript runtime.

Browsers:
 Chrome - V8
 Edge - Chakra
 FireFox -Spider Monkey


Hermes is an open-source JavaScript engine optimized for React Native
.....................................................................................
				How to build react native apps


There are two work flows 

1.Using React native lib
2.Using Expo framework


1.Using React native lib

React Native lib is core lib which offers core components for building native application development

if you want to build professional mobile app you need lot of infrastructure.
 UI Components
    -Views,Text,Labels,ListViews,ScrollView,TabView...........

React native core team provides all core components necessary to build mobile apps.

What if i want more components which is not supported by react core team.

You need to look at community or companies who provides professional mobile apps.

-Community -https://reactnative.directory/


2.Using Expo framework

 Expo  is a framwork built on the top of ReactNative core lib

What is expo?

 Expo is a framework and a platform for universal React native applications. It is a set of tools and services built around React Native and native platforms that help you develop, build, deploy, and quickly iterate on iOS, Android, and web apps from the same JavaScript/TypeScript codebase.

Expo Apps are created using 2 ways


Managed Work flow:

  With the managed workflow you only write JavaScript / TypeScript and Expo tools and services take care of everything else for you.

  The managed workflow is kind of like Rails and Create React App, but for React Native.

Apps are built with the managed workflow using the expo-cli, the Expo Go app on your mobile device, and our various services: push notifications, the build service, and over-the-air (OTA) updates. 

Expo tries to manage as much of the complexity of building apps for you as we can, which is why we call it the managed workflow.

 A developer using the managed workflow doesn't use Xcode or Android Studio, they just write JavaScript code and manage configuration for things like the app icon and splash screen through app.json.

 The Expo SDK exposes an increasingly comprehensive set of APIs that give you the power to access device capabilities like the camera, biometric authentication, file system, haptics, and so on.

Bare Work flow:

  In the bare workflow you have full control over every aspect of the native project, and Expo tools and services are a little more limited.

In the bare workflow the developer has complete control, along with the complexity that comes with that. You can use most APIs in the Expo SDK, but the build service and easy Configuration with app.json / app.config.js are not yet supported.

.....................................................................................

Running your React Native application in case of expo work flow:
.................................................................

1.You can run and test app inside browser itself- this is not recommended for complex apps.

2.You can run inside your device directly.
  Expo offers called expo client.
3.You can use emulators -Andorid virtual devices or emulators.

Metro Bundler:
-Online compiler, compiles code into react native 
....................................................................................
				Project setup

1.Using Reactive lib work flow

Requirements

-Windows - os
-Android 

Dependencies:
1.Node - 14+
2.JDK - 11

Open Cmd Prompt:

java --version
java 11.0.11 2021-04-20 LTS
Java(TM) SE Runtime Environment 18.9 (build 11.0.11+9-LTS-194)
Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.11+9-LTS-194, mixed mode)

node --version
v16.15.0


Kindly follow the Official documentation for installing necessary setups

1.Android studio
2.SDK
3.AVD Managers
https://reactnative.dev/docs/environment-setup

.....................................................................................

React Native Project setup.

npx react-native init ProjectName


Note:
 Before running npx command, if you have installed react-native cli via npm 
for eg:
npm install react-native-cli -g
You have to uninstall other wise it will give some error.

npm uninstall react-native-cli -g


npx react-native init myreactnativeApp

How to run app?
cd "E:\session\IBM\2022\july\ReactNative\myreactnativeApp" && npx react-native run-android
.....................................................................................
			   Expo Work flow Setup
....................................................................................


Expo work flow:
..............

Using npm

npm install expo-cli --global
expo init myNewProject
cd myNewProject
expo start

Using npx

npx create-expo-app expoapp && cd expoapp
.....................................................................................
				React Native Core Components
.....................................................................................

React Native offers lot of components but some components are core components.

Basic components:
..................

1.View
2.Text
3.Image
4.TextInput
5.ScrollView
6.StyleSheet

1.View:
.......
  The most fundamental component for building a UI, View is a container that supports layout with flexbox, style, some touch handling, and accessibility controls. View maps directly to the native view equivalent on whatever platform React Native is running on, whether that is a UIView, <div>, android.view, etc.


import { View } from "react-native";

//Root Component
function App() {
   return <View>
   </View>
}

export default App;

2.Text
	
A React component for displaying text.

Text supports nesting, styling, and touch handling.



import { Text, View } from "react-native";

//Root Component
function App() {
    return <View>
        <Text>
            Hello,React Native
        </Text>
        <Text>
            Hello,React Native
        </Text>
        <Text>
            Hello,React Native
        </Text>
    </View>
}

export default App;
.....................................................................................					 JSX basic Rules
....................................................................................

JSX follows XML rules for markup design.

1.In XML elements must organized under one parent element/root element, if not then it will throw error, same pattern is followed in react jsx as well.

Error code
<p>hai</p>
<p>hai</p>
  <Text>
            Hello,React Native
        </Text>
        <Text>
            Hello,React Native
        </Text>
        <Text>
            Hello,React Native
        </Text>

<div>
<p>hai</p>
<p>hai</p>
</div>
<View>
        <Text>
            Hello,React Native
        </Text>
        <Text>
            Hello,React Native
        </Text>
        <Text>
            Hello,React Native
        </Text>
    </View>

some times i dont want container elements.

React 16 onwards, it is possible to have without container elements, with help of fragements

Fragements are used to avoid unncessary view/div elements.
Fragements are invisible container component.

<React.Fragement>

<React.Fragment>
        <Text>
            Hello,React Native
        </Text>
        <Text>
            Hello,React Native
        </Text>
    </React.Fragment>

Short cut:

import React,{Fragment} from "react";
import { Text, View } from "react-native";

//Root Component
function App() {
    return <Fragment>
        <Text>
            Hello,React Native
        </Text>
        <Text>
            Hello,React Native
        </Text>
    </Fragment>
}

export default App;


import React, { Fragment } from "react";
import { Text, View } from "react-native";

//Root Component
// function App() {
//     return <View>
//         <Text>
//             Hello,React Native
//         </Text>
//         <Text>
//             Hello,React Native
//         </Text>
//     </View>
// }
const App = () => <View>
    <Text>
        Hello,React Native!
    </Text>
    <Text>
        Hello,React Native!!
    </Text>
</View>

export default App;
....................................................................................

....................................................................................
			      React Native Styles
.....................................................................................

Styles:

React Native applications are platform independant: if android means, android spefic styles
should be applied, if ios means ios specific styles should be challenge.
                                                     
						     
 						      |----Android
 Common Style language/lib/framework----|build tool---|----IOS


CSS is style language for web -browsers.

Can we use CSS language for React Native?

No!.

React Native uses CSS INSIDE javascript:

In React

css
.box{
  background-color :'red'
 }

Way1
 <div className="box">

way 2

javascript style object
 <div style={ {backgroundColor:'red'} } />

javascript style object properties:
https://www.w3schools.com/jsref/dom_obj_style.asp


React Native style representation:

1.StyleSheet  is object through we can create styles and can be attached to any React native
elements.

Style can be applied in twos

1.inline style object
<View>

</View>

2.external style object
<View>

</View>


import { View, Text, StyleSheet } from "react-native"


// const App = () => {
//     // inline style 
//     return <View style={{backgroundColor:'pink'}}>
//         <Text>
//             Welcome to React Native
//         </Text>
//     </View>
// }

//external style object 
const styles = StyleSheet.create({
    backgroundColor: 'yellow'
})


const App = () => {
    // inline style 
    return <View style={styles}>
        <Text>
            Welcome to React Native
        </Text>
    </View>
}
export default App;
.....................................................................................
		    Styling Indivdual Components
....................................................................................

Component is collection of userinterface elements like view,text...

How to write style for View and Text separtely.

const styles = StyleSheet.create({
    container: { 
	 backgroundColor: 'yellow'
    }
})

eg:
import { View, Text, StyleSheet } from "react-native"


// const App = () => {
//     // inline style 
//     return <View style={{backgroundColor:'pink'}}>
//         <Text>
//             Welcome to React Native
//         </Text>
//     </View>
// }

//external style object 
// const styles = StyleSheet.create({
//     backgroundColor: 'yellow'
// })

const styles = StyleSheet.create({
    container: {
        backgroundColor: 'yellow'
    },
    text: {
        fontSize: 100,
        color: "red",
    }

})


const App = () => {
    // inline style 
    return <View style={styles.container}>
        <Text style={styles.text}>
            Welcome to React Native
        </Text>
    </View>
}
export default App;
.....................................................................................
		How to simplify the code using object destructuring
.....................................................................................
import { View, Text, StyleSheet } from "react-native"


// const App = () => {
//     // inline style 
//     return <View style={{backgroundColor:'pink'}}>
//         <Text>
//             Welcome to React Native
//         </Text>
//     </View>
// }

//external style object 
// const styles = StyleSheet.create({
//     backgroundColor: 'yellow'
// })

// const styles = StyleSheet.create({
//     container: {
//         backgroundColor: 'yellow'
//     },
//     text: {
//         fontSize: 100,
//         color: "red",
//     }

// })

const { container, text } = StyleSheet.create({
    container: {
        backgroundColor: 'yellow'
    },
    text: {
        fontSize: 100,
        color: "blue",
    }

})


const App = () => {
    // inline style 
    return <View style={container}>
        <Text style={text}>
            Welcome to React Native
        </Text>
    </View>
}
export default App;
.....................................................................................
Tasks:

1. Component Composition - Layouts
2. Props - objects,primitives
3. Component driven design - props from parent to child and child to its child
.....................................................................................
.....................................................................................
				Style Composing
.....................................................................................

StyleSheet.compose:
Combines two styles such that style2 will override any styles in style1. If either style is falsy, the other one is returned without allocating an array, saving allocations and maintaining reference equality for PureComponent checks

import React from 'react';
import { StyleSheet, Text, View } from 'react-native';

const App = () => (
    <View style={container}>
        <Text style={text}>React Native</Text>
    </View>
);

export const page = StyleSheet.create({
    //style-1
    container: {
        flex: 1,
        padding: 24,
        backgroundColor: 'yellow',
    },
    text: {
        fontSize: 30,
        color: '#000'
    },
});

const lists = StyleSheet.create({
    //style-2
    listContainer: {
        flex: 1,
        backgroundColor: 'green',
    },
    listItem: {
        fontStyle: 'italic',
        fontWeight: 'bold'
    },
});

//here style one will be overriden by style2
const container = StyleSheet.compose(page.container, lists.listContainer);
const text = StyleSheet.compose(page.text, lists.listItem);

export default App;
....................................................................................
We can write global styles for the entire app and we can override for any where in the app.

eg:
myexpo/globalstyles
page.js
import { StyleSheet } from "react-native";

export const page = StyleSheet.create({
    //style-1
    container: {
        flex: 1,
        padding: 24,
        backgroundColor: 'yellow',
    },
    text: {
        fontSize: 30,
        color: '#000'
    },
});

App.js
import React from 'react';
import { StyleSheet, Text, View } from 'react-native';
import { page } from './globalstyles/page';

const App = () => (
    <View style={container}>
        <Text style={text}>React Native</Text>
    </View>
);

const lists = StyleSheet.create({
    //style-2
    listContainer: {
        flex: 1,
       // backgroundColor: 'green',
    },
    listItem: {
        fontStyle: 'italic',
        fontWeight: 'bold'
    },
});

//here style one will be overriden by style2
const container = StyleSheet.compose(page.container, lists.listContainer);
const text = StyleSheet.compose(page.text, lists.listItem);

export default App;
.....................................................................................

.....................................................................................
				StyleSheet Properties
....................................................................................

1.absoluteFill :

A very common pattern is to create overlays with position absolute and zero positioning (position: 'absolute', left: 0, right: 0, top: 0, bottom: 0), so absoluteFill can be used for convenience and to reduce duplication of these repeated styles.

import React from 'react';
import { StyleSheet, Text, View } from 'react-native';

const App = () => (
    <View style={styles.container}>
        <View style={styles.box1}>
            <Text style={styles.text}>1</Text>
        </View>
        <View style={styles.box2}>
            <Text style={styles.text}>2</Text>
        </View>
        <View style={styles.box3}>
            <Text style={styles.text}>3</Text>
        </View>
    </View>
);

const styles = StyleSheet.create({
    container: {
        flex: 1
    },
    box1: {
        position: 'absolute',
        top: 40,
        left: 40,
        width: 100,
        height: 100,
        backgroundColor: 'red'
    },
    box2: {
        /**
         * ...StyleSheet.obsoluteFill to be merged with existing styles with default values.
         * ...spread operator is used here to merge with existing object properties
         */
        ...StyleSheet.absoluteFill,
        width: 100,
        height: 100,
        backgroundColor: 'blue'
    },
    box3: {
        position: 'absolute',
        top: 120,
        left: 120,
        width: 100,
        height: 100,
        backgroundColor: 'green'
    },
    text: {
        color: '#FFF',
        fontSize: 80
    }
});

export default App;
/////////////////////////////////////////////////////////////////////////////////////
                            hairlineWidth
import React from "react";
import { StyleSheet, Text, View } from "react-native";

const App = () => (
    <View style={styles.container}>
        <Text style={styles.row}>React</Text>
        <Text style={styles.row}>Native</Text>
    </View>
);

const styles = StyleSheet.create({
    container: {
        flex: 1,
        padding: 24
    },
    row: {
        padding: 4,
        borderBottomColor: "red",
        borderBottomWidth: StyleSheet.hairlineWidth
    }
});

export default App
..................................................................................
.....................................................................................
			   Component Composition
.....................................................................................

import { React } from 'react'

import { View, Text, StyleSheet } from 'react-native'

const Greeter = () => <>
    <Text>Greeter!!!</Text>
</>

//Root Component
const App = () => <View style={styles.container}>
    <Greeter />
</View>



const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
});
export default App;
....................................................................................
rootfolder
  -greeter
     Greeter.jsx
import { Text } from "react-native"

export const Greeter = () => <>
    <Text>Greeter</Text>
</>

rootFolder
  App.js
import { React } from 'react'
import { View, Text, StyleSheet } from 'react-native'
import { Greeter } from './greeter/Greeter';

//Root Component
const App = () => <View style={styles.container}>
    <Greeter />
</View>


const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
});
export default App;
....................................................................................
				Props -Data
....................................................................................
import { React } from 'react'
import { View, Text, StyleSheet } from 'react-native'
import { Greeter } from './greeter/Greeter';
import { User } from './users/User';

//Root Component
const App = () => <View style={styles.container}>
    <Greeter />
    <Greeter message="Hello" name="Subramanian" />
    <Greeter message="Hello" name="Ram" />
    <User user={{ id: 1, name: 'Subramanian', city: 'Coimbatore' }} skills={
        ['Java','Javascript','Devops','Cloud']
    } />
</View>


const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
});
export default App;
import { Text,View } from "react-native"

export const User = props => <>
    <Text>Id : {props.user.id}</Text>
    <Text>Name :{props.user.name}</Text>
    <Text>City : {props.user.city}</Text>
    <View>
        {
            props.skills.map(skill => {
                return <Text>{skill}</Text>
            })
        }

    </View>
</>
//Default Props
User.defaultProps = {
    user: {
        userId: 0,
        name: 'React Native',
        city: 'Coimbatore',
        skills: []
    }
}
.....................................................................................
				.....................................................................................
			  state,event handling
.....................................................................................
import { React, Component } from 'react'
import { View, Text, StyleSheet } from 'react-native'


//state 
export class Counter extends Component {
    state = {
        value: 10
    }
    render() {
        return <View>
            <Text>Counter App!!</Text>
            <Text>Value {this.state.value}</Text>
        </View>
    }
}

//Root Component
const App = () => <View style={styles.container}>
    <Counter />
</View>


const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
});
export default App;
.....................................................................................					Button Component

Button
A basic button component that should render nicely on any platform. Supports a minimal level of customization.

<Button
  onPress={onPressLearnMore}
  title="Learn More"
  color="#841584"
  accessibilityLabel="Learn more about this purple button"
/>

import { React, Component } from 'react'
import { View, Text, StyleSheet, Button } from 'react-native'


//state 
export class Counter extends Component {
    state = {
        value: 10
    }
    onIncrement = () => {
        this.setState((prevState) => {
            return { ...prevState, value: prevState.value + 1 }
        })
    }   

    render() {
        return <View>
            <Text>Counter App!!</Text>
            <Text>Value {this.state.value}</Text>
            <Button
                onPress={this.onIncrement}
                title="Increment"
                color="#841584"
                accessibilityLabel="Learn more about this purple button"
            />
        </View>
    }
}

//Root Component
const App = () => <View style={styles.container}>
    <Counter />
</View>


const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
});
export default App;
.....................................................................................
....................................................................................
			    Hooks
....................................................................................
What is Hooks?
  Hooks are a new addition in React 16.8. They let you use state and other React features without writing a class.
 Hook is  a plain js function.


Why hooks?

1. Code Resue
  if you to repeate biz logic of component , in class component is not possible
via hooks(functions) it is possible

2.Code reduction
  to eleminate lot of boiler plate code

Hook is just simple javascript function.
which may take arg or may not.
Which may or may not return something 	


every hook function starts with
  "use"+functionName ==>hook Syntax

eg:
"useState"
"useContext"
"useEffect"
"useAjax"
"useWebSocket"
"useLayout"
etc....
you can create your own hooks as well.


useState:
.........
const [state, setState] = useState(initialState);
Returns a stateful value, and a function to update it.

During the initial render, the returned state (state) is the same as the value passed as the first argument (initialState).

The setState function is used to update the state. It accepts a new state value and enqueues a re-render of the component.

Simple Hook:

Hook can be primtive,object ,array.

import { React, useState } from 'react'
import { View, Text, StyleSheet, Button } from 'react-native'

export const Counter = props => {
    const [counter, setCounter] = useState(10)

    const onIncrement = () => {
        setCounter(oldCounter => {
            return oldCounter + 1
        })
    }
    return <>
        <Text>Value {counter}</Text>
        <Button title="Increment" onPress={onIncrement} />
    </>
}


//Root Component
const App = () => <View style={styles.container}>
    <Text>Counter App</Text>
    <Counter />
</View>

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
});
export default App;
...................................................................................
				 Dynamic props
		        Component Driven Design principles


As we discussed the component must be broken into smaller and smaller

Component = {state + api + UI}
 
The component having state and biz logic is called as "StateFull Component"

Any StateFull Component should have UI code.

StateLess Components are components which receives data as prop and will UI.
When ever the compoent receives props the compoent rerenders.

The Parent Component would be statefull component
The child component would be stateless component.

eg:
import { React, useState } from 'react'
import { View, Text, StyleSheet, Button } from 'react-native'

//stateFull component: Parent
export const Counter = props => {
    const [counter, setCounter] = useState(15)
    const onIncrement = () => {
        setCounter(oldCounter => {
            return oldCounter + 1
        })
    }
    return <>
        {/* dynamic props :state as prop , function as prop */}
        <CounterDisplay counter={counter} onIncrement={onIncrement} />
    </>
}

//stateLess compoent: only receives props 
export const CounterDisplay = props => {
    const { counter, onIncrement } = props
    return <>
        <Text>Value {counter}</Text>
        <Button title="Increment" onPress={onIncrement} />
    </>
}

//Root Component
const App = () => <View style={styles.container}>
    <Text>Counter App</Text>
    <Counter />
</View>

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
});
export default App;
....................................................................................
			Multi Hooks,Object inside useState.

import { React, useState } from 'react'
import { View, Text, StyleSheet, Button } from 'react-native'


export const Counter = () => {
    const [value, setValue] = useState(200)
    const [like, setLike] = useState(100)
    const [counter, setCounter] = useState({ value: 10 })

    const onIncrement = () => {
        setValue(previousValue => {
            return previousValue + 1
        })
    }
    const onLike = () => {
        setLike(previousValue => {
            return previousValue + 1
        })
    }
    //object mutation
    const onCounter = () => {
        setCounter(oldState => {
            return { ...oldState, value: oldState.value + 1 }
        })
    }

    return <View>
        <Text>Counter Value {value} Like {like}</Text>
        <Text>Counter Object {counter.value}</Text>

        <Button
            onPress={onIncrement}
            title="Increment"
            color="#841584"
            accessibilityLabel="Learn more about this purple button"
        />
        <View style={{ marginTop: 10 }}>
            <Button
                onPress={onLike}
                title="Like"
                color="#841584"
                accessibilityLabel="Learn more about this purple button"
            />
        </View>
        <View style={{ marginTop: 10 }}>
            <Button
                onPress={onCounter}
                title="Counter Object"
                color="#841584"
                accessibilityLabel="Learn more about this purple button"
            />
        </View>
    </View>

}

//Root Component
const App = () => <View style={styles.container}>
    <Counter />
</View>


const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
});
export default App;
....................................................................................
			User Input- TextInput Component
....................................................................................

A foundational component for inputting text into the app via a keyboard. Props provide configurability for several features, such as auto-correction, auto-capitalization, placeholder text, and different keyboard types, such as a numeric keypad.

The most basic use case is to plop down a TextInput and subscribe to the onChangeText events to read the user input. There are also other events, such as onSubmitEditing and onFocus that can be subscribed to


import { React, useState } from 'react'
import { View, Text, StyleSheet, Button, TextInput, Alert } from 'react-native'

export const UserInput = props => {
    //declare state to capture input values
    const [text, setText] = useState('defaultValue')
    //listener method takes arg called event object 
    //event object is bridge object 
    const onUpdate = name  => {
        //read Text Box value and update text 
        setText(name)
    }
    const onGetValue = () => {
        Alert.alert(text)
        setText('')
    }
    return <View>
        <Text style={styles.label}>Enter Your Name</Text>
        {/* TextInput */}
        <TextInput style={styles.input} onChangeText={onUpdate} value={text} />
        <Button title="GetText" onPress={onGetValue} />
    </View>
}


//Root Component
const App = () => <View style={styles.container}>
    <UserInput />
</View>


const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
    label: {
        fontSize: 25,
        color: 'red'
    },
    input: {
        height: 40,
        width: 300,
        margin: 12,
        borderWidth: 3,
        padding: 10
    },
    listItem: {
        padding: 10,
        marginVertical: 10,
        backgroundColor: 'pink'
    }
});
export default App;
.....................................................................................TextInput Properties:

1.defaultValue
2.editable
3.multiline
4.autofocus
5.maxlength
6.Place Holder

How to declare TextInput to Accept passwords:

secureTextEntry 
If true, the text input obscures the text entered so that sensitive text like passwords stay secure. The default value is false. Does not work with multiline={true}.
 <TextInput style={styles.input}
            placeholder="Password"
            placeholderTextColor="#9a73ef"
            returnKeyType='go'
            secureTextEntry
            autoCorrect={false}
        />
import { React, useState } from 'react'
import { View, Text, StyleSheet, Button, TextInput, Alert } from 'react-native'

const UserInput = () => {
    //state variable to capture user intput
    const [text, setText] = useState('Greet')
    // const update = name => {
    //     setText(name)
    // }
    return <View>
        <Text style={styles.label}>Enter Your Name</Text>
        {/* inline listener */}
        <TextInput multiline={true} style={styles.input} autoFocus={true} defaultValue={'default'} onChangeText={name => {
            setText(name)
        }} />
        <Text style={styles.label}>Enter Your Password</Text>
        {/* inline listener */}
        <TextInput style={styles.input}
            placeholder="Password"
            placeholderTextColor="#9a73ef"
            returnKeyType='go'
            secureTextEntry
            autoCorrect={false}
        />
        <Text style={styles.label}>Your Name is : {text}</Text>
        {/* Inline listner */}
        <Button title='Show Name' onPress={() => {
            Alert.alert(text)
        }} />
    </View>
}

//Root Component
const App = () => <View style={styles.container}>
    <UserInput />
</View>


const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
    label: {
        fontSize: 25,
        color: 'red'
    },
    input: {
        height: 40,
        width: 300,
        margin: 12,
        borderWidth: 1,
        padding: 10
    },
    listItem: {
        padding: 10,
        marginVertical: 10,
        backgroundColor: 'pink'
    }
});
export default App;
.....................................................................................
....................................................................................
				Design-Colors
...................................................................................

How to use colors?

 -color names; red blue; which is not mostly recommended.
 -color values ; #

Color Representation:

RGB
HSL
color int
color strings

https://reactnative.dev/docs/colors

Colors API
 React Native has several color APIs designed to allow you to take full advantage of your platform's design and user preferences.

PlatformColor 
  lets you reference the platform's color system.

PlatformColor(color1, [color2, ...colorN]);

 You can use the PlatformColor function to access native colors on the target platform by supplying the native color’s corresponding string value

If you pass more than one string value to the PlatformColor function, it will treat the first value as the default and the rest as fallback.

PlatformColor('bogusName', 'linkColor');

Supported colors
:
For a full list of the types of system colors supported.

Android:
 R.attr - ?attr prefix
 R.color - @android:color prefix

iOS (Objective-C and Swift notations):
UIColor Standard Colors
UIColor UI Element Colors


DynamicColorIOS 
   is iOS specific and allows you to specify which colors should be used in light or Dark Mode.
.....................................................................................
				Platform

Platform is Object , used to detect on which platform you are in, accordingly if you want to render some features like, colors.

Platform class offers static properties
constants
	Version,Release...
isPadiOS
isTV
isTesting
OS
Version

methods:
Platform.select(config:Object)

The config parameter is an object with the following keys:
android (any)
ios (any)
native (any)
default (any)

Platform.select({
 android: ?
 ios:?
})

select method how works?
 select internally applies if logic to select os

Platform.OS === 'platform' or a Platform.select()
.
import React from 'react';

import {
    Platform,
    PlatformColor,
    StyleSheet,
    Text,
    View
} from 'react-native';


const App = () => (
    <View style={styles.container}>
        <Text style={styles.label}>
            I am a special label color!	
        </Text>
    </View>
);

const styles = StyleSheet.create({
    label: {
        padding: 16,
        ...Platform.select({
            ios: {
                color: PlatformColor('label'),
                backgroundColor:
                    PlatformColor('systemTealColor'),
            },
            android: {
                color: PlatformColor('?android:attr/textColor'),
                backgroundColor:
                    PlatformColor('@android:color/holo_blue_bright'),
            },
            default: { color: 'black' }
        })
    },
    container: {
        flex: 1,
        alignItems: 'center',
        justifyContent: 'center',
        ...Platform.select({
            ios: {
                color: PlatformColor('label'),
                backgroundColor:
                    PlatformColor('systemTealColor'),
            },
            android: {
                color: PlatformColor('?android:attr/textColor'),
                backgroundColor:
                    PlatformColor('@android:color/holo_orange_dark'),
            },
            default: { color: 'black' }
        })
    }
});

export default App;
....................................................................................
.................................................................................
			Design - Height and Width
..................................................................................

Height and Width
 A component's height and width determine its size on the screen.

Fixed Dimensions
   The general way to set the dimensions of a component is by adding a fixed width and height to style. All dimensions in React Native are unitless, and represent density-independent pixels

import React from 'react';
import {
    View
} from 'react-native';

const FixedDimensionsBasics = () => {
    return (
        <View>
            <View style={{
                width: 50, height: 50, backgroundColor: 'powderblue'
            }} />
            <View style={{
                width: 100, height: 100, backgroundColor: 'skyblue'
            }} />
            <View style={{
                width: 150, height: 150, backgroundColor: 'steelblue'
            }} />
        </View>
    );
};

const App = () => <FixedDimensionsBasics />



export default App;

The problems in fixed width Dimensions:

1.if device size changes, which will not update the ui according to screen sizes.
.....................................................................................

Flex Dimensions / Flexable Deminisions

  Use flex in a component's style to have the component expand and shrink dynamically based on available space.

Layouts:
........
-Every UI, Design starts with box, Box model.
-Every Element/Widget/Component is a box.


Every Box has the following properties

1.width
2.height

measurements are specified using device px, in react native we dont tell units.

 width: 100px / 100% -html

The value of width  of an component , in general the "width of container"
The value of height of an component ,the component height.

space :

Space can be allocated of an component 

1.margin
   The space allocated outside component
2.padding
  The space allocated inside component

Faces of widget:
................

Clock wise order
 Top---Right---bottom--left

space allocation based on sides

leftMargin:10
rightMargin:10
topMargin:10
bottomMargin:10

padding : left,right,top,bottom

Allocate 10px padding and margin equally in all sides

padding : 10
margin :10

Layout types in css/Web:

1.box layout - height,width,float,alignments
2.grid layout
3.flex box

Flex Box:

What is flex box / flex?

The flex box is specification introduced in css  to build responsive web application alternate to grid layout.

flexbox is one dimensional layout model, where as gird layout is two dimensional layout.

Any layout is box based design

layout is rendered as row-column coimbation : two dimensional layout
     "Grid"

layout is rendered either row or column direction ; one dimensional layout 
     "Flex"


Flex box basics:

Axes of Flex:
 There are two types of axes

1.Main axis
2.Cross axis

How to activate the flex layout?

 Flex layout is already activated in side every react native elements.

we can override flex property
eg:

flex : 1 

flex will define how your items are going to “fill” over the available space along your main axis. Space will be divided according to each element's flex property.

The main axis is defined by "flex-direction" which has four values

 row
 row-reverse
 column
 column-reverse

 flexDirection: row | column | row-reverse | column-reverse

https://medium.com/wix-engineering/the-full-react-native-layout-cheat-sheet-a4147802405c

https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox

https://yogalayout.com/docs


import React, { Component } from 'react';
import { View, Text } from 'react-native';

export default class FlexDirectionBasics extends Component {
  render() {
    return (
      // Try setting `flexDirection` to 'column'/'column-reverse'/'row'/'row-reverse'
      <View style={styles.container}>
        <Text style={styles.headerStyle}>flexDirection: 'row-reverse'</Text>
        <View style={[{flexDirection:'column-reverse'}, styles.elementsContainer]}>
          <View style={{width: 50, height: 50, backgroundColor: '#EE2C38'}} />
          <View style={{width: 50, height: 50, backgroundColor: '#FAA030'}} />
          <View style={{width: 50, height: 50, backgroundColor: '#32B76C'}} />
        </View>
      </View>
    );
  }
}

const styles = {
  container: {
    marginTop: 48,
    flex: 1
  },
  headerStyle: {
    fontSize: 24,
    textAlign: 'center',
    fontWeight: '100',
    marginBottom: 24
  },
  elementsContainer: {
    flex: 1,
    backgroundColor: '#ecf5fd',
    marginLeft: 24,
    marginRight: 24,
    marginBottom: 24
  }
}
.....................................................................................
			 Mobile App Layouts
.....................................................................................

Mobile Apps are mostly based on layoutting model is called "ListView"

View Types:

1.View 
   Container View which contains other views and components
   It does not Scrollable
2.ScrollView
3.FlatList

import { StatusBar } from 'expo-status-bar';
import { ScrollView, StyleSheet, Text, View } from 'react-native';
import { Greeter } from './greeter/greeter';


export default function App() {
    return (
        <View style={styles.container}>
            <ScrollView>
                <Greeter title="Welcome to React Native!!" />
                <Greeter title="Welcome to React Native!!" />
                <Greeter title="Welcome to React Native!!" />
                <Greeter title="Welcome to React Native!!" />
                <Greeter title="Welcome to React Native!!" />
                <Greeter title="Welcome to React Native!!" />
                <Greeter title="Welcome to React Native!!" />
                <Greeter title="Welcome to React Native!!" />
                <Greeter title="Welcome to React Native!!" />
                <Greeter title="Welcome to React Native!!" />
                <Greeter title="Welcome to React Native!!" />
                <Greeter title="Welcome to React Native!!" />
                <Greeter title="Welcome to React Native!!" />
                <Greeter title="Welcome to React Native!!" />
                <Greeter title="Welcome to React Native!!" />
                <Greeter title="Welcome to React Native!!" />
                <Greeter title="Welcome to React Native!!" />
                <Greeter title="Welcome to React Native!!" />
                <Greeter title="Welcome to React Native!!" />
                <Greeter title="Welcome to React Native!!" />
                <Greeter title="Welcome to React Native!!" />
                <Greeter title="Welcome to React Native!!" />
                <Greeter title="Welcome to React Native!!" />
                <Greeter title="Welcome to React Native!!" />
                <Greeter title="Welcome to React Native!!" />
                <Greeter title="Welcome to React Native!!" />
                <Greeter title="Welcome to React Native!!" />
                <Greeter title="Welcome to React Native!!" />
                <Greeter title="Welcome to React Native!!" />
                <Greeter title="Welcome to React Native!!" />
                <Greeter title="Welcome to React Native!!" />
                <Greeter title="Welcome to React Native!!" />
                <Greeter title="Welcome to React Native!!" />
                <Greeter title="Welcome to React Native!!" />
                <Greeter title="Welcome to React Native!!" />
                <Greeter title="Welcome to React Native!!" />
                <Greeter title="Welcome to React Native!!" />
            </ScrollView>
            <StatusBar style="auto" />
        </View>
    );
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
});
....................................................................................
			 FlatList

.....................................................................................
				FlatList and SectionList
.....................................................................................


FlatList: 

To render list along with scrollbar.

<ScrollView> vs <FlatList> - which one to use?

ScrollView renders all its react child components at once, but this has a performance downside.

Imagine you have a very long list of items you want to display, maybe several screens worth of content. Creating JS components and native views for everything all at once, much of which may not even be shown, will contribute to slow rendering and increased memory usage.

This is where FlatList comes into play. FlatList renders items lazily, when they are about to appear, and removes items that scroll way off screen to save memory and processing time.

FlatList is also handy if you want to render separators between your items, multiple columns, infinite scroll loading, or any number of other features it supports out of the box.

Fully cross-platform.
Optional horizontal mode.
Configurable viewability callbacks.
Header support.
Footer support.
Separator support.
Pull to Refresh.
Scroll loading.
ScrollToIndex support.
Multiple column support.

Syntax:
const users = [{id:1,name:'a'}]

<FlatList 
         keyExtractor={(item)=>item.id} 
         data={users}
         renderItem={({item}) => (
            <Text style={styles.item}>{item.name}</Text>
)} />

keyExtractor:
	which is eq key prop in react.
(item: object, index: number) => string;

Used to extract a unique key for a given item at the specified index. Key is used for caching and as the react key to track item re-ordering. The default extractor checks item.key, then item.id, and then falls back to using the index, like React does.

eg:  
  users.map(user=>{
     return <li key={user.id}>
	
   </li>
  })

data:
  which binds array as data source

renderItem : {renderItemFunction}

renderItemFunction(item:Object,index:number,separators:Object){
	
}

  <FlatList
            data={messageList}
            renderItem={
                (obj) => {
                    console.log(obj)
                    return <Text>something</Text>
                }
            }
        />

output:
Object {
  "index": 0,
  "item": Object {
    "id": 1,
    "message": "hello",
  },
  "separators": Object {
    "highlight": [Function highlight],
    "unhighlight": [Function unhighlight],
    "updateProps": [Function updateProps],
  },
}
renderItem function returns one single object which has three keys

1.index
2.item
3.separators

 <FlatList
            data={messageList}
            renderItem={
                (obj) => {
                    console.log(obj)
                    return <Text>{obj.item.message}</Text>
                }
            }
        />
        <FlatList
            data={messageList}
            renderItem={
                ({ item, index, separators }) => {
                    console.log(item, index, separators)
                    return <Text>{item.message}</Text>
                }
            }
        />
        <FlatList
            data={messageList}
            renderItem={
                ({ item, index, separators }) => {
                    console.log(item, index, separators)
                    const { message } = item
                    return <Text>{message}</Text>
                }
            }
        />
.....................................................................................import React, { Component } from 'react';
import { View, Text, FlatList } from 'react-native';


const messageList = [{
    id: 1,
    message: 'hello'
},
{
    id: 2,
    message: 'hai'
},
{
    id: 3,
    message: 'welcome'
},
{
    id: 4,
    message: 'greet'
}

]

const App = () => {
    // Try setting `flexDirection` to 'column'/'column-reverse'/'row'/'row-reverse'
    return <View style={styles.container}>
        <Text style={styles.headerStyle}>ListView</Text>
         {/* <FlatList
            data={messageList}
            renderItem={
                (obj) => {
                    console.log(obj)
                    return <Text>{obj.item.message}</Text>
                }
            }
        /> */}
        {/* <FlatList
            data={messageList}
            renderItem={
                ({ item, index, separators }) => {
                    console.log(item, index, separators)
                    return <Text>{item.message}</Text>
                }
            }
        /> */}
        <FlatList
            keyExtractor={(message) => {
                console.log('keyExtractor', message)
                return message.id
            }}
            data={messageList}
            renderItem={
                ({ item, index, separators }) => {
                    console.log(item, index, separators)
                    const { message } = item
                    return <Text>{message}</Text>
                }
            }
        /> 
    </View>
}

const styles = {
    container: {
        marginTop: 48,
        backgroundColor: 'pink',
        flex: 1
    },
    headerStyle: {
        fontSize: 24,
        fontWeight: 'bolder',
        textAlign: 'center',
        marginBottom: 24
    },
    elementsContainer: {
        flex: 1,
        paddingLeft: 10,
        paddingTop: 10,
        backgroundColor: '#ecf5fd',
        marginLeft: 24,
        marginRight: 24,
        marginBottom: 24
    }
}

export default App;
....................................................................................
Todo items with FlatList


import React from 'react';
import { View, Text, FlatList } from 'react-native';
import { TODOS } from './mock-data/todos'


const App = () => {
    return <View style={styles.container}>
        <Text style={styles.headerStyle}>Todo List</Text>
        <FlatList
            keyExtractor={(todo) => {
                return todo.id
            }}
            data={TODOS}
            renderItem={
                ({ item, index, separators }) => {
                    console.log(item, index, separators)
                    const { title } = item
                    return <Text>{title}</Text>
                }
            }
        />
    </View>
}

const styles = {
    container: {
        marginTop: 48,
        backgroundColor: 'pink',
        flex: 1
    },
    headerStyle: {
        fontSize: 24,
        fontWeight: 'bolder',
        textAlign: 'center',
        marginBottom: 24
    },
    elementsContainer: {
        flex: 1,
        paddingLeft: 10,
        paddingTop: 10,
        backgroundColor: '#ecf5fd',
        marginLeft: 24,
        marginRight: 24,
        marginBottom: 24
    }
}

export default App;
....................................................................................
			Web Service Integration
....................................................................................

How to talk rest apis/end points/webservices?
 Javascript provides an api called XMLHTTPRequest called ajax object.

XHR is very low level api used for api communications.
Now a days we have frameworks/libs built on the top xhr.

Popular libs:
1.fetch - from google
2.axios - third party community
etc...


When to make api calls in Ui apps.

1.during inital render
  when you lanuch app, you need to load data ,that time we need to talk to api
2.after user interaction
  when you submit a form,you press some item, when you press a menu...

1.during inital render
  when you lanuch app, you need to load data ,that time we need to talk to api

Component Life Cycles:
......................

Every Component has three life cycle phase.
Each Phase has different apis

Phases
1.mount
   This phase is a inital phase

constructor - not used widely even in class components
2.render :
   render is method used to prepare inital "virtual object tree"
after render completes,
  React engine will insert virtual object tree into platforms(browser / mobile)

3.componentDidMount is called
   Inside componentDidMount we are going to perform most expensive operations
eg:
  ajax/api calls
  Timers
  Websocket calls

2.update
3.unmount

import React from 'react';
import { View, Text } from 'react-native';


class UserList extends React.Component {
    constructor() {
        super()
        console.log('UserList - Constructor is called')
    }
    render() {
        console.log('UserList - render is called')
        return <>
            <Text>User List</Text>
            <UserDetails/>
        </>
    }
    componentDidMount() {
        console.log('UserList - ComponentDidMount')
    }
}

class UserDetails extends React.Component {
    constructor() {
        super()
        console.log('UserDetails - Constructor is called')
    }
    render() {
        console.log('UserDetails - render is called')
        return <>
            <Text>User Details</Text>
        </>
    }
    componentDidMount() {
        console.log('UserDetails - ComponentDidMount')
    }
}


const App = () => {
    return <View style={styles.container}>
        <Text style={styles.headerStyle}>Component Life Cycle</Text>
        <UserList />
    </View>
}

const styles = {
    container: {
        marginTop: 48,
        backgroundColor: 'pink',
        flex: 1
    },

}

export default App;
.....................................................................................

API call
Conditional Rendering
ActivityIndicator
Item Selection

import React from 'react';
import { View, Text, ActivityIndicator, FlatList, StyleSheet, StatusBar, Alert } from 'react-native';


class Todos extends React.Component {

    state = {
        error: null,
        isLoaded: false, //progress bar / spinner 
        items: [] //data
    }

    onSelectItem = item => {
        Alert.alert(JSON.stringify(item))
    }
    render() {
        const { error, isLoaded, items } = this.state
        //conditional rendering
        if (error) {
            return <View>
                <Text>Error : {error.message}</Text>
            </View>
        } else if (!isLoaded) {
            //show spinner 
            return <ActivityIndicator size="large" color="#0000ff" />
        } else {
            return <FlatList
                keyExtractor={(todo) => {
                    return todo.id
                }}
                data={items}
                renderItem={
                    ({ item }) => {
                        const { title } = item
                        return <View style={styles.item}>
                            <Text onPress={() => { this.onSelectItem(item) }} style={styles.title}>{title}</Text>
                        </View>
                    }
                }
            />
        }

    }
    componentDidMount() {
        setTimeout(() => {
            const url = 'https://jsonplaceholder.typicode.com/todos'
            fetch(url)
                .then(res => res.json())
                .then(todos => {
                    // console.log(todos)
                    this.setState({
                        isLoaded: true,
                        items: todos
                    })
                })
                .catch(err => {
                    console.log(err)
                    this.setState({
                        isLoaded: true,
                        error: err
                    })
                })
        }, 100)
    }
}


const App = () => {
    return <View style={styles.container}>
        <Todos />
    </View>
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        marginTop: StatusBar.currentHeight || 0,
    },
    item: {
        backgroundColor: '#f9c2ff',
        padding: 20,
        marginVertical: 8,
        marginHorizontal: 16,
    },
    title: {
        fontSize: 32,
    },
});

export default App;
.....................................................................................
			 Functional Components

How to handle life cycle apis in functional components?
 hooks
componentDidMount -- useEffect(()=>{})

import React, { useEffect, useState } from 'react';
import { View, Text, ActivityIndicator, FlatList, StyleSheet, StatusBar, Alert } from 'react-native';

export const Todos = props => {
    const [state, setState] = useState({
        error: null,
        isLoaded: false, //progress bar / spinner 
        items: [] //data
    })
    const onSelectItem = item => {
        Alert.alert(JSON.stringify(item))
    }
    
    useEffect(() => {
        setTimeout(() => {
            const url = 'https://jsonplaceholder.typicode.com/todos'
            fetch(url)
                .then(res => res.json())
                .then(todos => {
                    // console.log(todos)
                    setState({
                        isLoaded: true,
                        items: todos
                    })
                })
                .catch(err => {
                    console.log(err)
                    setState({
                        isLoaded: true,
                        error: err
                    })
                })
        }, 100)
    })
    const { error, isLoaded, items } = state
    //conditional rendering
    if (error) {
        return <View>
            <Text>Error : {error.message}</Text>
        </View>
    } else if (!isLoaded) {
        //show spinner 
        return <ActivityIndicator size="large" color="#0000ff" />
    } else {
        return <FlatList
            keyExtractor={(todo) => {
                return todo.id
            }}
            data={items}
            renderItem={
                ({ item }) => {
                    const { title } = item
                    return <View style={styles.item}>
                        <Text onPress={() => { onSelectItem(item) }} style={styles.title}>{title}</Text>
                    </View>
                }
            }
        />
    }

}

const App = () => {
    return <View style={styles.container}>
        <Todos />
    </View>
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        marginTop: StatusBar.currentHeight || 0,
    },
    item: {
        backgroundColor: '#f9c2ff',
        padding: 20,
        marginVertical: 8,
        marginHorizontal: 16,
    },
    title: {
        fontSize: 32,
    },
});

export default App;
...................................................................................
				Handling Touch Features in Mobile:
.....................................................................................


Handling Touch Features in Mobile:
...................................
Users interact with mobile apps mainly through touch. They can use a combination of gestures, such as tapping on a button, scrolling a list, or zooming on a map. React Native provides components to handle all sorts of common gestures, as well as a comprehensive gesture responder system to allow for more advanced gesture recognition, but the one component you will most likely be interested in is the basic Button.


Touchable Components:
.....................

If the basic button doesn't look right for your app, you can build your own button using any of the "Touchable" components provided by React Native. The "Touchable" components provide the capability to capture tapping gestures, and can display feedback when a gesture is recognized. These components do not provide any default styling

TouchableHighlight:

import { StatusBar } from 'expo-status-bar';
import { StyleSheet, Text, Button, TouchableHighlight, View, Alert } from 'react-native';

function App() {
    return (
        <View style={styles.container}>
            <TouchableHighlight activeOpacity={0.6} underlayColor="#DDDDDD" onPress={() => Alert.alert('Pressed')}>
                <Button style={{ backgroundColor: '#fff',fontSize:50 }} title="Touch Me"/>
            </TouchableHighlight>
        </View>
    );
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#000',
        alignItems: 'center',
        justifyContent: 'center',
    },
});

export default App;
////////////////////////////////////////////////////////////////////////////////////
			Component as Prop
...................................................................................

<TouchableHighlight>
   <Button/>
</TouchableHighlight>	
<View>
  ?
</View>		

<MyComponent/>  - the component does not take any child elements
...................................................................................
import { StyleSheet, Text, Image, View } from 'react-native';

const Header = props => {
    //  Component as prop
    return <View>
        {props.children}
    </View>
}
const Logo = props => {
    return <Image style={styles.img} source={{uri:'https://reactnative.dev/img/tiny_logo.png'}} />
}

const MyText = props => <Text>{props.title}</Text>

function App() {
    return (
        <View style={styles.container}>
            <Header>
                <MyText title="Hello" />
                <Logo/>
            </Header>
        </View>
    );
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#ffff',
        alignItems: 'center',
        justifyContent: 'center',
    },
    img: {
        width:50,
        height:50
    }
});

export default App;
.....................................................................................
				Status Bar
....................................................................................
StatusBar
Component to control the app's status bar. The status bar is the zone, typically at the top of the screen, that displays the current time, Wi-Fi and cellular network information, battery level and/or other status icons.

 <StatusBar
        animated={true}
        backgroundColor="#61dafb"
        barStyle={statusBarStyle}
        showHideTransition={statusBarTransition}
        hidden={hidden} />

import React, { useState } from 'react';
import { Button, Platform, SafeAreaView, StatusBar, StyleSheet, Text, View } from 'react-native';

const STYLES = ['default', 'dark-content', 'light-content'];
const TRANSITIONS = ['fade', 'slide', 'none'];

const App = () => {
    const [hidden, setHidden] = useState(false);
    const [statusBarStyle, setStatusBarStyle] = useState(STYLES[2]);
    const [statusBarTransition, setStatusBarTransition] = useState(TRANSITIONS[1]);

    const changeStatusBarVisibility = () => setHidden(!hidden);

    const changeStatusBarStyle = () => {
        const styleId = STYLES.indexOf(statusBarStyle) + 1;
        if (styleId === STYLES.length) {
            setStatusBarStyle(STYLES[0]);
        } else {
            setStatusBarStyle(STYLES[styleId]);
        }
    };

    const changeStatusBarTransition = () => {
        const transition = TRANSITIONS.indexOf(statusBarTransition) + 1;
        if (transition === TRANSITIONS.length) {
            setStatusBarTransition(TRANSITIONS[0]);
        } else {
            setStatusBarTransition(TRANSITIONS[transition]);
        }
    };

    return (
        <SafeAreaView style={styles.container}>
            <StatusBar
                animated={true}
                backgroundColor="#61dafb"
                barStyle={statusBarStyle}
                showHideTransition={statusBarTransition}
                hidden={hidden} />
            <Text style={styles.textStyle}>
                StatusBar Visibility:{'\n'}
                {hidden ? 'Hidden' : 'Visible'}
            </Text>
            <Text style={styles.textStyle}>
                StatusBar Style:{'\n'}
                {statusBarStyle}
            </Text>
            {Platform.OS === 'ios' ? (
                <Text style={styles.textStyle}>
                    StatusBar Transition:{'\n'}
                    {statusBarTransition}
                </Text>
            ) : null}
            <View style={styles.buttonsContainer}>
                <Button
                    title="Toggle StatusBar"
                    onPress={changeStatusBarVisibility} />
                <Button
                    title="Change StatusBar Style"
                    onPress={changeStatusBarStyle} />
                {Platform.OS === 'ios' ? (
                    <Button
                        title="Change StatusBar Transition"
                        onPress={changeStatusBarTransition} />
                ) : null}
            </View>
        </SafeAreaView>
    );
};

const styles = StyleSheet.create({
    container: {
        flex: 1,
        justifyContent: 'center',
        backgroundColor: '#ECF0F1'
    },
    buttonsContainer: {
        padding: 10
    },
    textStyle: {
        textAlign: 'center',
        marginBottom: 8
    }
});

export default App;


....................................................................................
				Switch Component

in order to toggle , enable and disable features.

import React from 'react';
import { View, Button, Text, ScrollView, StyleSheet, StatusBar, Switch } from 'react-native'

let id = 0

const styles = StyleSheet.create({
    todoContainer: {
        marginTop: 50,
        flexDirection: 'row',
        alignItems: 'center',
    },
    appContainer: {
        paddingTop: 10,
        marginTop: 20,

    },
    // Let container (ScrollView (todo container) & View (app container)) fills up all possible space
    fill: {
        flex: 1,
    }
})

export const Todo = props => (
    <View style={styles.todoContainer}>
        <Switch value={props.todo.checked} onValueChange={props.onToggle} />
        <Button onPress={props.onDelete} title="delete" />
        <Text>{props.todo.text}</Text>
    </View>
)
class App extends React.Component {
    state = {
        todos: [],
    }
    addTodo() {
        id++
        const text = `TODO number ${id}`
        this.setState({
            todos: [
                ...this.state.todos,
                { id: id, text: text, checked: false },
            ],
        })
    }

    removeTodo(id) {
        this.setState({
            todos: this.state.todos.filter(todo => todo.id !== id)
        })
    }

    toggleTodo(id) {
        this.setState({
            todos: this.state.todos.map(todo => {
                if (todo.id !== id) return todo
                return {
                    id: todo.id,
                    text: todo.text,
                    checked: !todo.checked,
                }
            })
        })
    }

    render() {
        return (
            <View style={[styles.appContainer, styles.fill]}>
                <StatusBar
                    animated={true}
                    backgroundColor="#61dafb"
                    barStyle={"default"}
                    showHideTransition={"fade"}
                    hidden={false} />
                <Text>Todo count: {this.state.todos.length}</Text>
                <Text>Unchecked todo count: {this.state.todos.filter(todo => !todo.checked).length}</Text>
                <Button onPress={() => this.addTodo()} title="Add TODO" />
                <ScrollView style={styles.fill}>
                    {this.state.todos.map(todo => (
                        <Todo
                            onToggle={() => this.toggleTodo(todo.id)}
                            onDelete={() => this.removeTodo(todo.id)}
                            todo={todo}
                        />
                    ))}
                </ScrollView>
            </View>
        )
    }
}

export default App;
...................................................................................
.....................................................................................
				ImageBackground

A common feature request from developers familiar with the web is background-image. To handle this use case, you can use the <ImageBackground> component, which has the same props as <Image>, and add whatever children to it you would like to layer on top of it.

import React from "react";
import { ImageBackground, StyleSheet, Text, View } from "react-native";

const image = { uri: "https://reactjs.org/logo-og.png" };

const App = () => (
  <View style={styles.container}>
    <ImageBackground source={image} resizeMode="cover" style={styles.image}>
      <Text style={styles.text}>Inside</Text>
    </ImageBackground>
  </View>
);

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  image: {
    flex: 1,
    justifyContent: "center"
  },
  text: {
    color: "white",
    fontSize: 42,
    lineHeight: 84,
    fontWeight: "bold",
    textAlign: "center",
    backgroundColor: "#000000c0"
  }
});

export default App;
....................................................................................
import React, { useState } from "react";
import { Alert, Modal, StyleSheet, Text, Pressable, View } from "react-native";

const App = () => {
    const [modalVisible, setModalVisible] = useState(false);
    return (
        <View style={styles.centeredView}>
            <Modal
                animationType="fade"
                transparent={true}
                visible={modalVisible}
                onRequestClose={() => {
                    Alert.alert("Modal has been closed.");
                    setModalVisible(!modalVisible);
                }}
            >
                <View style={styles.centeredView}>
                    <View style={styles.modalView}>
                        <Text style={styles.modalText}>Hello World!</Text>
                        <Pressable
                            style={[styles.button, styles.buttonClose]}
                            onPress={() => setModalVisible(!modalVisible)}
                        >
                            <Text style={styles.textStyle}>Hide Modal</Text>
                        </Pressable>
                    </View>
                </View>
            </Modal>
            <Pressable
                style={[styles.button, styles.buttonOpen]}
                onPress={() => setModalVisible(true)}
            >
                <Text style={styles.textStyle}>Show Modal</Text>
            </Pressable>
        </View>
    );
};

const styles = StyleSheet.create({
    centeredView: {
        flex: 1,
        justifyContent: "center",
        alignItems: "center",
        marginTop: 22
    },
    modalView: {
        margin: 20,
        backgroundColor: "white",
        borderRadius: 20,
        padding: 35,
        alignItems: "center",
        shadowColor: "#000",
        shadowOffset: {
            width: 0,
            height: 2
        },
        shadowOpacity: 0.25,
        shadowRadius: 4,
        elevation: 5
    },
    button: {
        borderRadius: 20,
        padding: 10,
        elevation: 2
    },
    buttonOpen: {
        backgroundColor: "#F194FF",
    },
    buttonClose: {
        backgroundColor: "#2196F3",
    },
    textStyle: {
        color: "white",
        fontWeight: "bold",
        textAlign: "center"
    },
    modalText: {
        marginBottom: 15,
        textAlign: "center"
    }
});

export default App;
.....................................................................................
Navigation
 Page
 Drawer
 Tab
Device Features
  expo components
camera
contacts
network
etc...
State Management- Redux
....................................................................................
			   React Native navigation

				App Arch with Navigation

<App>
  <NavigationContainer>

  </NavigationContainer>
</App>

Navigation Objects:
...................
1.NavigationContainer

import { NavigationContainer } from '@react-navigation/native';
import { StatusBar } from 'expo-status-bar';
import { StyleSheet, Text, View, Image } from 'react-native';

export const Home = props => {
    return <View>
        <Text>Home</Text>
    </View>
}


const App = () => {
    return <View style={styles.container}>
        <NavigationContainer>
            {/* Here You have render Menu */}
            <Home/>
        </NavigationContainer>
    </View>
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    }
});
export default App;
....................................................................................
Rendering Screen: HomeScreen

import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { StyleSheet, Text, View } from 'react-native';

export const HomeScreen = props => {
    return <View style={styles.container}>
        <Text>Home Screen</Text>
    </View>
}

//create Object By calling createNativeStackNavigator function 
const Stack = createNativeStackNavigator()
console.log(Stack)

const App = () => {
    return <NavigationContainer>
        <Stack.Navigator>
            <Stack.Screen name="Home" component={HomeScreen} />
        </Stack.Navigator>
    </NavigationContainer>
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    }
});
export default App;

..................................................................................

....................................................................................
			   How to move between screens
..................................................................................

Navigating to a new screen​

Every Component receives information from the parent component as a prop.
When component is rendered via route,React Navigator injects an object called "Navigation" Object as prop to every Component


Props;
Object {
  "navigation": Object {
    "addListener": [Function addListener],
    "canGoBack": [Function canGoBack],
    "dispatch": [Function dispatch],
    "getId": [Function getId],
    "getParent": [Function getParent],
    "getState": [Function anonymous],
    "goBack": [Function anonymous],
    "isFocused": [Function isFocused],
    "navigate": [Function anonymous],
    "pop": [Function anonymous],
    "popToTop": [Function anonymous],
    "push": [Function anonymous],
    "removeListener": [Function removeListener],
    "replace": [Function anonymous],
    "reset": [Function anonymous],
    "setOptions": [Function setOptions],
    "setParams": [Function anonymous],
  },
  "route": Object {
    "key": "Home-V-z_dGCJfqcHgNXxzxRGK",
    "name": "Home",
    "params": undefined,
  },

import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { StyleSheet, Text, View, Button } from 'react-native';

//create Object By calling createNativeStackNavigator function 
const { Navigator, Screen } = createNativeStackNavigator()

export const HomeScreen = props => {
    console.log('home', props)
    const { navigation } = props;
    const moveToScreen = () => {
       // props.navigation.navigate('Details')
       navigation.navigate('Details')
    }
    return <View style={styles.container}>
        <Text>Home Screen</Text>
        <Button title="Go Details" onPress={moveToScreen} />
    </View>
}
export const DetailsScreen = props => {
    return <View style={styles.container}>
        <Text>Details Screen</Text>
    </View>
}

const App = () => {
    return <NavigationContainer>
        <Navigator>
            {/* Routes  name of the route is represented by name */}
            <Screen name="Home" component={HomeScreen} />
            <Screen name="Details" component={DetailsScreen} />
        </Navigator>
    </NavigationContainer>
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    }
});
export default App;


navigation - the navigation prop is passed in to every screen component (definition) in the native stack navigator 

navigate('Details') - we call the navigate function (on the navigation prop — naming is hard!) with the name of the route that we'd like to move the user to.
import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { StyleSheet, Text, View, Button } from 'react-native';

export const HomeScreen = props => {
    console.log('home', props)
    const { navigation } = props;
    const moveToScreen = () => {
        // props.navigation.navigate('Details')
        navigation.navigate('Details')
    }
    return <View style={styles.container}>
        <Text>Home Screen</Text>
        <Button title="Go Details" onPress={moveToScreen} />
    </View>
}

export const DetailsScreen = props => {
    console.log('home', props)
    const { navigation } = props;
    const moveToScreen = () => {
        // props.navigation.navigate('Details')
        navigation.navigate('Greeter')
    }
    return <View style={styles.container}>
        <Text>Home Screen</Text>
        <Button title="Greeter" onPress={moveToScreen} />
    </View>
}

const GreeterScreen = props => <Text>Greeter</Text>
//create Object By calling createNativeStackNavigator function 
const Stack = createNativeStackNavigator()
console.log(Stack)

const App = () => {
    return <NavigationContainer>
        <Stack.Navigator>
            <Stack.Screen name="Home" component={HomeScreen} />
            <Stack.Screen name="Details" component={DetailsScreen} />
            <Stack.Screen name="Greeter" component={GreeterScreen} />

        </Stack.Navigator>
    </NavigationContainer>
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    }
});
export default App;
.....................................................................................
				Use Case

Show Home Screen
  --->TodosScreen - AJAX To fetch data from the end point
        -DetailsScreen--> Current Todo.

import React, { useEffect, useState } from 'react';
import { View, Text, ActivityIndicator, FlatList, StyleSheet, StatusBar, Alert } from 'react-native';

export const Todos = props => {
    const [state, setState] = useState({
        error: null,
        isLoaded: false, //progress bar / spinner 
        items: [] //data
    })
    const onSelectItem = item => {
        Alert.alert(JSON.stringify(item))
    }
    
    useEffect(() => {
        setTimeout(() => {
            const url = 'https://jsonplaceholder.typicode.com/todos'
            fetch(url)
                .then(res => res.json())
                .then(todos => {
                    // console.log(todos)
                    setState({
                        isLoaded: true,
                        items: todos
                    })
                })
                .catch(err => {
                    console.log(err)
                    setState({
                        isLoaded: true,
                        error: err
                    })
                })
        }, 1000)
    })
    const { error, isLoaded, items } = state
    //conditional rendering
    if (error) {
        return <View>
            <Text>Error : {error.message}</Text>
        </View>
    } else if (!isLoaded) {
        //show spinner 
        return <ActivityIndicator size="large" color="#0000ff" />
    } else {
        return <FlatList
            keyExtractor={(todo) => {
                return todo.id
            }}
            data={items}
            renderItem={
                ({ item }) => {
                    const { title } = item
                    return <View style={styles.item}>
                        <Text onPress={() => { onSelectItem(item) }} style={styles.title}>{title}</Text>
                    </View>
                }
            }
        />
    }

}
const styles = StyleSheet.create({
    container: {
        flex: 1,
        marginTop: StatusBar.currentHeight || 0,
    },
    item: {
        backgroundColor: '#f9c2ff',
        padding: 20,
        marginVertical: 8,
        marginHorizontal: 16,
    },
    title: {
        fontSize: 32,
    },
});

.....................................................................................
			    Moving Screens from back to forth
.....................................................................................

There are two ways
1.Using back button as part of status bar.
2.Using code
  navigation.goBack()
  or
  navigation.navigate('screen')

import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { StyleSheet, Text, View, Button } from 'react-native';

//create Object By calling createNativeStackNavigator function 
const { Navigator, Screen } = createNativeStackNavigator()

export const HomeScreen = props => {
    console.log('home', props)
    const { navigation } = props;
    const moveToScreen = () => {
       // props.navigation.navigate('Details')
       navigation.navigate('Details')
    }
    return <View style={styles.container}>
        <Text>Home Screen</Text>
        <Button title="Go Details" onPress={moveToScreen} />
    </View>
}
export const DetailsScreen = props => {
    const {navigation} = props;
    return <View style={styles.container}>
        <Text>Details Screen</Text>
        <Button title="Go Back" onPress={()=>{
            navigation.goBack();
        }} />
    <Button title="Go to Home" onPress={() => navigation.navigate('Home')} />

    </View>
}

const App = () => {
    return <NavigationContainer>
        <Navigator>
            {/* Routes  name of the route is represented by name */}
            <Screen name="Home" component={HomeScreen} />
            <Screen name="Details" component={DetailsScreen} />
        </Navigator>
    </NavigationContainer>
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    }
});
export default App;

Router Properties: Screen Props:
...............................

Specifying options:
..................
Each screen in the navigator can specify some options for the navigator, such as the title to render in the header. These options can be passed in the options prop for each screen component:

<Stack.Screen
  name="Home"
  component={HomeScreen}
  options={{ title: 'Welcome to Start Token' }}
/>
..................................................................................
..................................................................................
			How to pass data to the Compoent via Props

Passing additional props#
.........................

Sometimes we might want to pass additional props to a screen.

We can do that with 2 approaches:

1.Use React context and wrap the navigator with a context provider to pass data to the screens (recommended).

2.Use a render callback for the screen instead of specifying a component prop:


import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { StyleSheet, Text, View, Button } from 'react-native';

//create Object By calling createNativeStackNavigator function 
const { Navigator, Screen } = createNativeStackNavigator()

export const HomeScreen = props => {
    const { navigation } = props;
    const moveToScreen = () => {
        navigation.navigate('Details')
    }
    return <View style={styles.container}>
        <Text>{props.title}</Text>
        <Button title="Go Details" onPress={moveToScreen} />
    </View>
}
HomeScreen.defaultProps = {
    title: 'Your Bank'
}

export const DetailsScreen = props => {
    const { navigation } = props;
    return <View style={styles.container}>
        <Text>Details Screen</Text>
        <Button
            title="Go to Details... again"
            onPress={() => navigation.push('Details')}
        />
        <Button title="Go Back" onPress={() => {
            navigation.goBack();
        }} />
        <Button title="Go to Home" onPress={() => navigation.navigate('Home')} />

    </View>
}

const App = () => {
    return <NavigationContainer>
        <Navigator>
            {/* Routes  name of the route is represented by name */}
            {/* <Screen name="Home" options={{ title: 'Welcome to Start Token' }} component={HomeScreen} /> */}
            <Screen name="Home" options={{ title: 'Welcome to Start Token' }}>
                {props => {
                    return <HomeScreen {...props}  title="Bank of India - Home" />
                }}
            </Screen>

            <Screen name="Details" component={DetailsScreen} />
        </Navigator>
    </NavigationContainer>
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    }
});
export default App;

..................................................................................
			How to pass data to the Compoent via Props

Passing additional props#
.........................

Sometimes we might want to pass additional props to a screen.

We can do that with 2 approaches:

1.Use React context and wrap the navigator with a context provider to pass data to the screens (recommended).

2.Use a render callback for the screen instead of specifying a component prop:


import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { StyleSheet, Text, View, Button } from 'react-native';

//create Object By calling createNativeStackNavigator function 
const { Navigator, Screen } = createNativeStackNavigator()

export const HomeScreen = props => {
    const { navigation } = props;
    const moveToScreen = () => {
        navigation.navigate('Details')
    }
    return <View style={styles.container}>
        <Text>{props.title}</Text>
        <Button title="Go Details" onPress={moveToScreen} />
    </View>
}
HomeScreen.defaultProps = {
    title: 'Your Bank'
}

export const DetailsScreen = props => {
    const { navigation } = props;
    return <View style={styles.container}>
        <Text>Details Screen</Text>
        <Button
            title="Go to Details... again"
            onPress={() => navigation.push('Details')}
        />
        <Button title="Go Back" onPress={() => {
            navigation.goBack();
        }} />
        <Button title="Go to Home" onPress={() => navigation.navigate('Home')} />

    </View>
}

const App = () => {
    return <NavigationContainer>
        <Navigator>
            {/* Routes  name of the route is represented by name */}
            {/* <Screen name="Home" options={{ title: 'Welcome to Start Token' }} component={HomeScreen} /> */}
            <Screen name="Home" options={{ title: 'Welcome to Start Token' }}>
                {props => {
                    return <HomeScreen {...props}  title="Bank of India - Home" />
                }}
            </Screen>

            <Screen name="Details" component={DetailsScreen} />
        </Navigator>
    </NavigationContainer>
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    }
});
export default App;
.....................................................................................
How to tell which routes should be displayed first? - as Home

1.Generally Based on order the first screen will be rendered as Home Route.
2.In the Navigator , we can tell "initialRouteName"

With Screen Order:
  <NavigationContainer>
            <Navigator>
	
                <Screen name="Home"  options={{ title: 'Welcome to Start Token' }}>
                    {props => <HomeScreen {...props} extraData={"Start Token"} />}
                </Screen>
              
                <Screen  name="Details" component={DetailsScreen} />
            </Navigator>
        </NavigationContainer>


With inital Route Name
eg:
  <NavigationContainer>
            <Navigator initialRouteName="Details">
                {/* <Screen options={{ title: 'Welcome to Start Token' }} name="Home" component={HomeScreen} /> */}
                <Screen name="Home"  options={{ title: 'Welcome to Start Token' }}>
                    {props => <HomeScreen {...props} extraData={"Start Token"} />}
                </Screen>
              
                <Screen  name="Details" component={DetailsScreen} />
            </Navigator>
        </NavigationContainer>
Recap:

React Native doesn't have a built-in API for navigation like a web browser does. React Navigation provides this for you, along with the iOS and Android gestures and animations to transition between screens.

Stack.Navigator is a component that takes route configuration as its children with additional props for configuration and renders our content.

Each Stack.Screen component takes a name prop which refers to the name of the route and component prop which specifies the component to render for the route. These are the 2 required props.

To specify what the initial route in a stack is, provide an initialRouteName as the prop for the navigator.

To specify screen-specific options, we can pass an options prop to Stack.Screen, and for common options, we can pass screenOptions to Stack.Navigator

.............................................................................................
                                        Passing parameters to routes
............................................................................................

Now that we know how to create a stack navigator with some routes and navigate between those routes, let's look at how we can pass data to routes when we navigate to them.

There are two pieces to this:

Pass params to a route by putting them in an object as a second parameter to the navigation.navigate function: navigation.navigate('RouteName', { /* params go here */ })

import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { StyleSheet, Text, View, Button } from 'react-native';

//create Object By calling createNativeStackNavigator function 
const { Navigator, Screen } = createNativeStackNavigator()

export const HomeScreen = props => {
    const { navigation } = props;
    const moveToScreen = () => {
        navigation.navigate('Details', { message: 'Hello' })
    }
    return <View style={styles.container}>
        <Text>{props.title}</Text>
        <Button title="Go Details" onPress={moveToScreen} />
    </View>
}
HomeScreen.defaultProps = {
    title: 'Your Bank'
}

export const DetailsScreen = props => {

    //props.route.params
    const { navigation, route: { params: { message } } } = props;
    // console.log(route)

    return <View style={styles.container}>
        <Text>Details Screen</Text>
        <Text>Data From Home Screen {message}</Text>
        <Button
            title="Go to Details... again"
            onPress={() => navigation.push('Details')}
        />
        <Button title="Go Back" onPress={() => {
            navigation.goBack();
        }} />
        <Button title="Go to Home" onPress={() => navigation.navigate('Home')} />

    </View>
}

const App = () => {
    return <NavigationContainer>
        <Navigator initialRouteName='Home'>
            <Screen name="Home" options={{ title: 'Welcome to Start Token' }}>
                {props => {
                    return <HomeScreen {...props} title="Bank of India - Home" />
                }}
            </Screen>

            <Screen name="Details" component={DetailsScreen} />
        </Navigator>
    </NavigationContainer>
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    }
});
export default App;
.....................................................................................
			Ajax calls with screen navigation
.....................................................................................

import { NavigationContainer } from '@react-navigation/native';
import React, { useEffect, useState } from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { View, Text, FlatList, StatusBar, Button, ActivityIndicator, StyleSheet, Alert } from 'react-native';

//create Object By calling createNativeStackNavigator function 
const { Navigator, Screen } = createNativeStackNavigator()

export const HomeScreen = props => {
    const { navigation } = props;
    const moveToScreen = () => {
        navigation.navigate('Post')
    }
    return <View style={styles.container}>
        <Button title="Post" onPress={moveToScreen} />
    </View>
}
HomeScreen.defaultProps = {
    title: ''
}

export const PostDetailsScreen = props => {
    const { navigation, route: { params: { item } } } = props;
    console.log(item)
    return <View style={styles.container}>
        <Text>{
            JSON.stringify(item)
        }</Text>
    </View>
}

export const PostScreen = props => {

    const { navigation } = props;

    const [posts, setPosts] = useState({
        error: null, // if any ajax error
        isLoaded: false, //Progress bar enabler
        items: []  // data to be filed
    })

    //componentDid == useEffect 
    useEffect(() => {
        const url = 'https://jsonplaceholder.typicode.com/posts'
        fetch(url)
            .then(res => res.json())
            .then(posts => {
                setTimeout(() => {
                    setPosts(prvState => {
                        return { ...prvState, isLoaded: true, items: posts }
                    });
                }, 0)

            }, (error) => {
                setPosts({
                    isLoaded: true,
                    error
                });
            })

    }, [])


    const onPressItem = item => {
        navigation.navigate('PostDetails', { item: item })
    }
    //use object destructuring
    const { error, items, isLoaded } = posts;

    if (error) {
        //render error component
        return <View style={styles.error}> Error: {error.message}</View>;
    } else if (!isLoaded) {
        return <View style={styles.loader}>
            <ActivityIndicator size="large" color="#00ff00" />
        </View>;
    } else {
        return <View styles={styles.container}>
            <FlatList
                keyExtractor={(post) => {
                    return post.id
                }}
                data={items}
                renderItem={
                    ({ item }) => {
                        const { title } = item
                        return <View style={styles.item}>
                            <Text onPress={() => { onPressItem(item) }} style={styles.title}>{title}</Text>
                        </View>
                    }
                }
            />
        </View>
    }

}





const App = () => {
    return <NavigationContainer>
        <Navigator initialRouteName='Home'>
            <Screen name="Home" options={{ title: 'Post Application' }}>
                {props => {
                    return <HomeScreen {...props} />
                }}
            </Screen>
            <Screen name="Post" component={PostScreen} />
            <Screen name="PostDetails" component={PostDetailsScreen} />
        </Navigator>
    </NavigationContainer>
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        marginTop: StatusBar.currentHeight || 0,
    },
    item: {
        backgroundColor: '#f9c2ff',
        padding: 20,
        marginVertical: 8,
        marginHorizontal: 16,
    },
    title: {
        fontSize: 32,
    },
});
export default App;

....................................................................................
			   setParams

Updating params#

Screens can also update their params, like they can update their state. The navigation.setParams method lets you update the params of a screen.
Basic usage:

navigation.setParams({
  query: 'someText',
})



import { NavigationContainer } from '@react-navigation/native';
import React, { useEffect, useState } from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { View, Text, FlatList, StatusBar, Button, ActivityIndicator, StyleSheet, Alert } from 'react-native';



//create Stack Object
const { Navigator, Screen } = createNativeStackNavigator();

const HomeScreen = props => {
    const { navigation, route } = props;
    return <View style={styles.container}>
        <Text>Home Screen : {props.extraData}</Text>
        <Button title="Go to Details" onPress={() => navigation.navigate('Details', { id: 1, item: 'React Native' })} />
    </View>
}
const DetailsScreen = (props) => {
    const { navigation, route } = props;
    console.log(route.params);
    return (
        <View style={styles.container}>
            <Text>Details Screen : {route.params.id} - {route.params.item}</Text>
            <Button
                title="Update Params"
                onPress={() => {
                    // navigation.push('Details', {
                    //     id: Math.floor(Math.random() * 100),
                    // })
                    navigation.setParams({ id: 900, item: 'foo' })
                }
                }
            />
        </View>
    );
}

const App = () => {
    return <NavigationContainer>
        <Navigator initialRouteName='Home'>
            <Screen name="Home" component={HomeScreen} options={{ title: 'Welcome to Start Token' }} />
            <Screen name="Details" component={DetailsScreen} />
        </Navigator>
    </NavigationContainer>
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
});


export default App;
......................................................................................
Initial params#

You can also pass some initial params to a screen. If you didn't specify any params when navigating to this screen, the initial params will be used. They are also shallow merged with any params that you pass. Initial params can be specified with an initialParams prop:

<Stack.Screen
  name="Details"
  component={DetailsScreen}
  initialParams={{ itemId: 42 }}
/>

import { NavigationContainer } from '@react-navigation/native';
import React, { useEffect, useState } from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { View, Text, FlatList, StatusBar, Button, ActivityIndicator, StyleSheet, Alert } from 'react-native';



//create Stack Object
const { Navigator, Screen } = createNativeStackNavigator();

const HomeScreen = props => {
    const { navigation, route } = props;
    return <View style={styles.container}>
        <Text>Home Screen : {props.extraData}</Text>
        <Button title="Go to Details" onPress={() => navigation.navigate('Details')} />
    </View>
}
const DetailsScreen = (props) => {
    const { navigation, route } = props;
    console.log(route.params);
    return (
        <View style={styles.container}>
            <Text>Details Screen : {route.params.id} - {route.params.item}</Text>
            <Button
                title="UpdateDefaultParams"
                onPress={() => {
                           navigation.setParams({ id: 900, item: 'foo' })
                }
                }
            />
        </View>
    );
}

const App = () => {
    return <NavigationContainer>
        <Navigator initialRouteName='Home'>
            <Screen name="Home" component={HomeScreen} options={{ title: 'Welcome to Start Token' }} />
            <Screen name="Details" initialParams={{ id: 1, item: 'React Native v2' }} component={DetailsScreen} />
        </Navigator>
    </NavigationContainer>
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
});


export default App;
....................................................................................
Passing params to a previous screen#

Params aren't only useful for passing some data to a new screen, but they can also be useful to pass data to a previous screen too. For example, let's say you have a screen with a create post button, and the create post button opens a new screen to create a post. After creating the post, you want to pass the data for the post back to previous screen.



import { NavigationContainer } from '@react-navigation/native';
import React, { useState, useEffect } from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { View, Text, TextInput, Button, StyleSheet } from 'react-native';



//create Stack Object
const { Navigator, Screen } = createNativeStackNavigator();

const HomeScreen = props => {
    const { navigation, route } = props;

    //DidMount,DidUpdate
    useEffect(() => {
        if (route.params?.post) {
            // Post updated, do something with `route.params.post`
            // For example, send the post to the server
        }
    }, [route.params?.post]);

    return <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>
        <Button
            title="Create post"
            onPress={() => navigation.navigate('CreatePost')}
        />
        <Text style={{ margin: 10 }}>Post: {route.params?.post}</Text>
    </View>
}
const CreatePostScreen = (props) => {
    const { navigation, route } = props;

    const [postText, setPostText] = useState('');

    return (<View style={styles.container}>
        <TextInput
            multiline
            placeholder="What's on your mind?"
            style={{ height: 200, padding: 10, backgroundColor: 'green' }}
            value={postText}
            onChangeText={setPostText}
        />
        <Button
            title="Done"
            onPress={() => {
                // Pass params back to home screen
                navigation.navigate('Home', { post: postText });
            }}
        />
    </View>
    );
}

const App = () => {
    return <NavigationContainer>
        <Navigator initialRouteName='Home'>
            <Screen name="Home" component={HomeScreen} options={{ title: 'PostMaster' }} />
            <Screen component={CreatePostScreen} name="CreatePost" />
        </Navigator>
    </NavigationContainer>
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
});


export default App;
.....................................................................................
Configuring the header bar

We've seen how to configure the header title already, but let's go over that again before moving on to some other options

A Screen component accepts options prop which is either an object or a function that returns an object, that contains various configuration options. The one we use for the header title is title, as shown in the following example.


import { NavigationContainer } from '@react-navigation/native';
import React, { useState, useEffect } from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { View, Text, TextInput, Button, StyleSheet } from 'react-native';



//create Stack Object
const { Navigator, Screen } = createNativeStackNavigator();

const HomeScreen = props => {
    const { navigation, route } = props;

    //DidMount,DidUpdate
    useEffect(() => {
        if (route.params?.post) {
            // Post updated, do something with `route.params.post`
            // For example, send the post to the server
        }
    }, [route.params?.post]);

    return <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>
        <Button
            title="Create post"
            onPress={() => navigation.navigate('CreatePost' ,{title:'My Post Screen'})}
        />
        <Text style={{ margin: 10 }}>Post: {route.params?.post}</Text>
    </View>
}
const CreatePostScreen = (props) => {
    const { navigation, route } = props;

    const [postText, setPostText] = useState('');

    return (<View style={styles.container}>
        <TextInput
            multiline
            placeholder="What's on your mind?"
            style={{ height: 200, padding: 10, backgroundColor: 'green' }}
            value={postText}
            onChangeText={setPostText}
        />
        <Button
            title="Done"
            onPress={() => {
                // Pass params back to home screen
                navigation.navigate('Home', { post: postText });
            }}
        />
    </View>
    );
}

const App = () => {
    return <NavigationContainer>
        <Navigator initialRouteName='Home'>
            <Screen name="Home" component={HomeScreen} options={{ title: 'PostMaster' }} />
            {/* <Screen component={CreatePostScreen} name="CreatePost" options={{
                title:"Post Form"
            }} /> */}
            <Screen
                name="CreatePost"
                component={CreatePostScreen}
                options={({ route }) => ({ title: route.params.title })}
            />
        </Navigator>
    </NavigationContainer>
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
});


export default App;
................................................................................
				Update title with setOptions


Updating options with setOptions#
.................................


import { NavigationContainer } from '@react-navigation/native';
import React, { useState, useEffect } from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { View, Text, TextInput, Button, StyleSheet } from 'react-native';



//create Stack Object
const { Navigator, Screen } = createNativeStackNavigator();

const HomeScreen = props => {
    const { navigation, route } = props
    return <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>
        <Text>Home Screen</Text>
        <Button
            title="Update the title"
            onPress={() => navigation.setOptions({ title: 'Updated!' })}
        />
    </View>
}


const App = () => {
    return <NavigationContainer>
        <Navigator initialRouteName='Home'>
            <Screen name="Home" component={HomeScreen} options={{ title: 'PostMaster' }} />

        </Navigator>
    </NavigationContainer>
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
});


export default App;
Configuring the header bar

We've seen how to configure the header title already, but let's go over that again before moving on to some other options

A Screen component accepts options prop which is either an object or a function that returns an object, that contains various configuration options. The one we use for the header title is title, as shown in the following example.


import { NavigationContainer } from '@react-navigation/native';
import React, { useState, useEffect } from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { View, Text, TextInput, Button, StyleSheet } from 'react-native';



//create Stack Object
const { Navigator, Screen } = createNativeStackNavigator();

const HomeScreen = props => {
    const { navigation, route } = props;

    //DidMount,DidUpdate
    useEffect(() => {
        if (route.params?.post) {
            // Post updated, do something with `route.params.post`
            // For example, send the post to the server
        }
    }, [route.params?.post]);

    return <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>
        <Button
            title="Create post"
            onPress={() => navigation.navigate('CreatePost' ,{title:'My Post Screen'})}
        />
        <Text style={{ margin: 10 }}>Post: {route.params?.post}</Text>
    </View>
}
const CreatePostScreen = (props) => {
    const { navigation, route } = props;

    const [postText, setPostText] = useState('');

    return (<View style={styles.container}>
        <TextInput
            multiline
            placeholder="What's on your mind?"
            style={{ height: 200, padding: 10, backgroundColor: 'green' }}
            value={postText}
            onChangeText={setPostText}
        />
        <Button
            title="Done"
            onPress={() => {
                // Pass params back to home screen
                navigation.navigate('Home', { post: postText });
            }}
        />
    </View>
    );
}

const App = () => {
    return <NavigationContainer>
        <Navigator initialRouteName='Home'>
            <Screen name="Home" component={HomeScreen} options={{ title: 'PostMaster' }} />
            {/* <Screen component={CreatePostScreen} name="CreatePost" options={{
                title:"Post Form"
            }} /> */}
            <Screen
                name="CreatePost"
                component={CreatePostScreen}
                options={({ route }) => ({ title: route.params.title })}
            />
        </Navigator>
    </NavigationContainer>
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
});


export default App;
................................................................................
				Update title with setOptions


Updating options with setOptions#
.................................


import { NavigationContainer } from '@react-navigation/native';
import React, { useState, useEffect } from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { View, Text, TextInput, Button, StyleSheet } from 'react-native';



//create Stack Object
const { Navigator, Screen } = createNativeStackNavigator();

const HomeScreen = props => {
    const { navigation, route } = props
    return <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>
        <Text>Home Screen</Text>
        <Button
            title="Update the title"
            onPress={() => navigation.setOptions({ title: 'Updated!' })}
        />
    </View>
}


const App = () => {
    return <NavigationContainer>
        <Navigator initialRouteName='Home'>
            <Screen name="Home" component={HomeScreen} options={{ title: 'PostMaster' }} />

        </Navigator>
    </NavigationContainer>
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
});


export default App;



Adjusting header styles#
.........................


There are three key properties to use when customizing the style of your header: headerStyle, headerTintColor, and headerTitleStyle.

headerStyle: a style object that will be applied to the View that wraps the header. If you set backgroundColor on it, that will be the color of your header.

headerTintColor: the back button and title both use this property as their color. In the example below, we set the tint color to white (#fff) so the back button and the header title would be white.

headerTitleStyle: if we want to customize the fontFamily, fontWeight and other Text style properties for the title, we can use this to do it.


import { NavigationContainer } from '@react-navigation/native';
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { View, Text, TextInput, Button, StyleSheet } from 'react-native';



//create Stack Object
const { Navigator, Screen } = createNativeStackNavigator();

const HomeScreen = props => {
    const { navigation, route } = props
    return <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>
        <Text>Home Screen</Text>
        <Button
            title="Update the title"
            onPress={() => navigation.setOptions({ title: 'Updated!' })}
        />
    </View>
}
function ProfileScreen({ navigation }) {
    return (
        <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>
            <Text>Profile screen</Text>
            <Button title="Go back" onPress={() => navigation.goBack()} />
        </View>
    );
}

const App = () => {
    return <NavigationContainer>
        <Navigator initialRouteName='Home' screenOptions={
            {
                headerStyle: {
                    backgroundColor: 'pink'
                }
            }
        }>
            <Screen name="Home" component={HomeScreen} options={
                { title: 'Home', headerStyle: { backgroundColor: '#f4511e', headerTintColor: '#fff' } }} />
            <Screen
                name="Profile"
                component={ProfileScreen}
                options={{ title: 'Profile Screen' }}
            />

        </Navigator>
    </NavigationContainer>
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
});


export default App;



Sharing common options across screens#

It is common to want to configure the header in a similar way across many screens. For example, your company brand color might be red and so you want the header background color to be red and tint color to be white. Conveniently, these are the colors we're using in our running example, and you'll notice that when you navigate to the DetailsScreen the colors go back to the defaults. Wouldn't it be awful if we had to copy the options header style properties from HomeScreen to DetailsScreen, and for every single screen component we use in our app? Thankfully, we do not. We can instead move the configuration up to the stack navigator under the prop screenOptions


//create Stack Object
const { Navigator, Screen } = createNativeStackNavigator();

const HomeScreen = props => {
    const { navigation, route } = props
    return <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>
        <Text>Home Screen</Text>
        <Button
            title="Go To Profile"
            onPress={() => navigation.navigate('Profile')}
        />
    </View>
}
function ProfileScreen({ navigation }) {
    return (
        <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>
            <Text>Profile screen</Text>
            <Button title="Go back" onPress={() => navigation.goBack()} />
        </View>
    );
}

const App = () => {
    return <NavigationContainer>
        <Navigator initialRouteName='Home' screenOptions={
            {
                headerStyle: {
                    backgroundColor: 'pink'
                }
            }
        }>
            <Screen name="Home" component={HomeScreen} options={
                { title: 'Home' }} />
            <Screen
                name="Profile"
                component={ProfileScreen}
                options={{ title: 'Profile Screen' }}
            />

        </Navigator>
    </NavigationContainer>
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
});


export default App;
.................................................................................
       Navigating to Different screens through Header Buttons
import { NavigationContainer } from '@react-navigation/native';
import React, { useEffect } from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { View, Text, TextInput, Button, StyleSheet } from 'react-native';



//create Stack Object
const { Navigator, Screen } = createNativeStackNavigator();

const HomeScreen = props => {
    const { navigation, route } = props
    return <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>
        <Text>Home Screen</Text>
        <Button
            title="Go To Profile"
            onPress={() => navigation.navigate('ProfileScreen')}
        />
    </View>
}
function ProfileScreen({ navigation }) {

    return (
        <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>
            <Text>Profile screen</Text>
            <Button title="Go back" onPress={() => navigation.goBack()} />
        </View>
    );
}

function App() {
    return (<NavigationContainer>
        <Navigator>
            <Screen
                name="Home"
                component={HomeScreen}
                options={{
                    headerTitle: (props) => <Text>Header</Text>,
                    headerRight: () => (
                        <Button
                            onPress={() => alert('This is a button!')}
                            title="Info"
                            color="black"
                        />
                    ),
                }}
            />
            <Screen
                name="ProfileScreen"
                component={ProfileScreen}
                options={({ navigation, route }) => ({
                    headerTitle: (props) => <Text>Counter</Text>,
                    headerRight: () => (
                        <Button
                            onPress={() => navigation.navigate('Home')}
                            title="Home Screen"
                            color="black"
                        />
                    )
                })}

            />
        </Navigator>
    </NavigationContainer>
    );
}
export default App
.....................................................................................

...................................................................................
				Nested Navigation

//Header Buttons
import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { View, Text, StyleSheet } from 'react-native';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';

//create Stack Object
const Tab = createBottomTabNavigator();
const Stack = createNativeStackNavigator();

const Home = props => {
    return <Tab.Navigator>
        <Tab.Screen name="Feed" component={Feed} />
        <Tab.Screen name="Messages" component={Messages} />
    </Tab.Navigator>
}

const Feed = props => {
    return <View style={styles.container}>
        <Text>Feed Screen</Text>
    </View>
}

const Messages = props => {
    return <View style={styles.container}>
        <Text>Messages Screen</Text>
    </View>
}
const Settings = props => {
    return <View style={styles.container}>
        <Text>Settings Screen</Text>
    </View>
}
function App() {
    return <NavigationContainer>
        <Stack.Navigator>
            <Stack.Screen
                name="Home"
                component={Home}
                options={{ headerShown: false }}
            />
            <Stack.Screen name="Settings" component={Settings} />
        </Stack.Navigator>
    </NavigationContainer>

}


const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
});

export default App
...................................................................................
			Navigating from tab to screen
...................................................................................

//Header Buttons
import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { View, Text, StyleSheet,Button } from 'react-native';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';

//create Stack Object
const Tab = createBottomTabNavigator();
const Stack = createNativeStackNavigator();

const Home = props => {
    return <Tab.Navigator>
        <Tab.Screen name="Feed" component={Feed} />
        <Tab.Screen name="Messages" component={Messages} />
    </Tab.Navigator>
}

const Feed = props => {
    return <View style={styles.container}>
        <Text>Feed Screen</Text>
    </View>
}

const Messages = props => {
    const { navigation } = props;
    return <View style={styles.container}>
        <Text>Messages Screen</Text>
        <Button title="go to Settions" onPress={() => {
             navigation.navigate('Settings')
        }} />
    </View>
}
const Settings = props => {
    return <View style={styles.container}>
        <Text>Settings Screen</Text>
    </View>
}
function App() {
    return <NavigationContainer>
        <Stack.Navigator>
            <Stack.Screen
                name="Home"
                component={Home}
                options={{ headerShown: false }}
            />
            <Stack.Screen name="Settings" component={Settings} />
        </Stack.Navigator>
    </NavigationContainer>

}


const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
});

export default App
...................................................................................
			 Advanced Tabs
...................................................................................

BottomTab
TopTab

Possibly the most common style of navigation in mobile apps is tab-based navigation. This can be tabs on the bottom of the screen or on the top below the header (or even instead of a header).

1.createBottomTabNavigator.
2.createMaterialBottomTabNavigator 
3.createMaterialTopTabNavigator 

Customizing the appearance​

npm i @expo/vector-icons

// You can import Ionicons from @expo/vector-icons/Ionicons if you use Expo or
// react-native-vector-icons/Ionicons otherwise.
import Ionicons from 'react-native-vector-icons/Ionicons';

// (...)

export default function App() {
  return (
    <NavigationContainer>
      <Tab.Navigator
        screenOptions={({ route }) => ({
          tabBarIcon: ({ focused, color, size }) => {
            let iconName;

            if (route.name === 'Home') {
              iconName = focused
                ? 'ios-information-circle'
                : 'ios-information-circle-outline';
            } else if (route.name === 'Settings') {
              iconName = focused ? 'ios-list-box' : 'ios-list';
            }

            // You can return any component that you like here!
            return <Ionicons name={iconName} size={size} color={color} />;
          },
          tabBarActiveTintColor: 'tomato',
          tabBarInactiveTintColor: 'gray',
        })}
      >
        <Tab.Screen name="Home" component={HomeScreen} />
        <Tab.Screen name="Settings" component={SettingsScreen} />
      </Tab.Navigator>
    </NavigationContainer>
  );
}

eg:
//Header Buttons
import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { View, Text, StyleSheet, Button } from 'react-native';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import Ionicons from 'react-native-vector-icons/Ionicons';
//create Stack Object
const Tab = createBottomTabNavigator();
const Stack = createNativeStackNavigator();

const Home = props => {
    console.log(props.route.name)
    return <Text>Home</Text>
}

const Feed = props => {
    return <View style={styles.container}>
        <Text>Feed Screen</Text>
    </View>
}

const Messages = props => {
    return <View style={styles.container}>
        <Text>Messages Screen</Text>

    </View>
}
const Settings = props => {
    return <View style={styles.container}>
        <Text>Settings Screen</Text>
    </View>
}
function App() {
    return <NavigationContainer>
        <Tab.Navigator
            screenOptions={({ route }) => ({
                tabBarIcon: ({ focused, color, size }) => {
                    //console.log(route, focused, color, size)
                    console.log(route)
                    if (route.name==='Feed') {
                        return <Ionicons name="md-checkmark-circle" size={32} color="green" />
                    }
                    //https://ionic.io/ionicons
                    return <Ionicons name="cart-outline" size={32} color="red" />
                },
                tabBarActiveTintColor: 'tomato',
                tabBarInactiveTintColor: 'gray',
            })}
        >
            <Tab.Screen name="Feed" component={Feed} />
            <Tab.Screen name="Messages" component={Messages} />
        </Tab.Navigator>
    </NavigationContainer>

}


const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: '#fff',
        alignItems: 'center',
        justifyContent: 'center',
    },
});

export default App
...................................................................................
			       Drawer Navigation
...................................................................................

Common pattern in navigation is to use drawer from left (sometimes right) side for navigating between screens.

Rules:

1.npm install @react-navigation/drawer
2.expo install react-native-gesture-handler react-native-reanimated
2.import 'react-native-gesture-handler';
   this must be top level import
3.babel.config.js

module.exports = function (api) {
  api.cache(true);
  return {
    presets: ['babel-preset-expo'],
    plugins: [
      'react-native-reanimated/plugin',
    ],
  };
};




import * as React from 'react';
import { Button, View } from 'react-native';
import { createDrawerNavigator } from '@react-navigation/drawer';
import { NavigationContainer } from '@react-navigation/native';

function HomeScreen({ navigation }) {
  return (
    <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>
      <Button
        onPress={() => navigation.navigate('Notifications')}
        title="Go to notifications"
      />
    </View>
  );
}

function NotificationsScreen({ navigation }) {
  return (
    <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>
      <Button onPress={() => navigation.goBack()} title="Go back home" />
    </View>
  );
}

const Drawer = createDrawerNavigator();

export default function App() {
  return (
    <NavigationContainer>
      <Drawer.Navigator initialRouteName="Home">
        <Drawer.Screen name="Home" component={HomeScreen} />
        <Drawer.Screen name="Notifications" component={NotificationsScreen} />
      </Drawer.Navigator>
    </NavigationContainer>
  );
}
.....................................................................................














